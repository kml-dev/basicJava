package f_oop2;

public class OOP2_01 {
	public static void main(String[] args) {
		/*
		 1. 상속(is ~a)
		   - 기존의 클래스를 재사용하여 새로운 클래스를 작성한다.
		   - 적은 양의 코드로 새로운 클래스를 작성할 수 있다.
		   - 새로 작성하고자 하는 클래스 뒤에 상속받고자 하는 클래스의 이름을
		     'extends'와 함께 써주기만 하면 된다.
		     
		     class Child extends Parent{
		     
		     }
		     
		   - 상속해주는 클래스를 조상클래스, 상속받는 클래스를 자손클래스라고 한다.
		     : 조상클래스 -> 부모클래스, 상위클래스, 기반클래스
		     : 자손클래스 -> 자식클래스, 하위클래스, 파생된 클래스
		     
		   - 멤버만 상속된다.
		   - 자손클래스의 멤버의 갯수는 조상클래스보다 항상 같거나 많다. 
		   
		   
		 2. 포함(has ~a)
		   - 상속 이외에 클래스를 재사용하는 방법
		   - 한 클래스의 멤버변수로 다른 클래스를 선언하는 방법
		 
		   - toString()
		   	: 인스턴스의 정보를 반환할 목적으로 만들어졌다.
		   	
		 3. 단일 상속
		   - 자바에서는 단일 상속(두 개 이상은 불가)만 가능하다.
		     class TVCR extends TV, VCR{  // 불가 
		     
		     }
		   - TV와 VCR에 같은 메서드가 존재할 때 어떤 것을 상속받을지 알 수 없다.
		   - 메서드의 명을 바꾼다면 기존에 메서드를 사용하던 모든 곳을 수정해 주어야 한다.
		   - 클래스 간의 관계가 보다 명확해지고 더욱 신뢰할 수 있도록 해준다.
		   
		 4. Object 클래스
		   - 모든 클래스의 상속계층도의 제일 위에 위치하는 조상 클래스이다.
		   - 다른 클래스로부터 상속받지 않는 클래스는 자동적으로 Object 클래스를 상속받는다.
		     class Tv{
		     
		     }
		     
		     class Tv extends Object{
		     
		     }
		     
		   - toString(), equals()와 같은 메서드를 따로 정의하지 않고 사용하는 것은
		     Object클래스에 정의된 것이기 때문이다.
		 
		 5. 오버라이딩(override)
		   - 조상 클래스로부터 상속받은 메서드의 내용을 수정하는 것
		   - 오버라이드의 조건 (선언부가 일치해야 한다.)
		     : 상속 받는 메서드의 이름이 같아야 한다.
		     : 매개변수의 갯수와 타입이 같아야 한다.
		     : 반환타입도 같아야 한다.
		     
		   - 조상클래스의 메서드를 자손클래스에서 오버라이드 할 때는 접근제어자를 조상 클래스의 메서드보다 좁은 범위를 선택할 수 없다.
		          예외는 조상클래스의 메서드보다 많이 선언할 수 없다.
		          인스턴스 메서드를 클래스 메서드로 변경할 수 없다.
		          
		 6. super.
		   - 조상클래스의 멤버와 자손클래스의 멤버가 중복 정의되어 서로 구분햐야하는 경우 사용
		   - 자손클래스에서의 멤버에서만 사용이 가능
		   - 조상의 멤버와 자신의 멤버를 구분하는데 사용된다는 점을 제외하고는 this.과 동일하다.
		   - 클래스메서드에는 사용할 수 없고 인스턴스 메서드에만 사용이 가능하다.
		   
		 7. super()
		   - this()와 마찬가지로 super()역시 생성자 호출이다.
		   - this()는 같은 클래스의 다른 생성자를 호출, super() 자손클래스의 생성자에서 
	                  부모클래스의 생성자를 호출할 때 사용한다.
	       - 생성자를 호출할 때 생성자의 가장 첫줄에 써야한다.
	       
	     8. 제어자
	       - 클래스, 메서드, 변수의 선언부에 사용된다.
	       - 접근제어자와 그 외 제어자로 나누어 진다.
	       - 접근제어자 : public, protected, default, private
	       - 그 외 제어자 : static, final, abstract
	       - 접근제어자와 그 외 제어자가 동시에 있을 때 접근제어자를 가장 왼쪽에 쓴다.
	       - static(클래스의, 공통적인)
	         : 메서드와 변수, 초기화 블럭에만 사용가능하다.
	         : 클래스변수 
	           -> 모든 인스턴스에서 공통적으로 사용
	           -> 인스턴스를 생성하지 않고 '클래스명.변수명'호출한다.
	           -> 클래스가 메모리에 로드될 때 함께 로드된다.
	           -> 클래스멤버에서는 인스턴스 멤버를 호출할 수 없다.
	           
	       - final(마지막의, 변경할 수 없는)
	         : 변수에 사용시 값을 변경할 수 없는 상수가 된다.
	         : 메서드에 사용시 오버라이드가 불가
	         : 클래스에 사용시 부모클래스가 될 수 없다.
	         
	       - abstract(추상의 , 미완성된)
	         : 메서드에 사용 시 선언부만 작성을 하고 구현부는 작성되지 않는다.
	         : 클래스에 사용 시 추상메서드를 가지고 있는 클래스임을 알린다.
	         
	     9. 접근제어자
	       - public : 접근제한이 없다.
	       - protected : 같은 패키지 + 다른 패키지의 자손클래스
	       - default : 같은 패키지 내에서 호출 가능
	       - private : 같은 클래스 내에서 호출 가능
	         
	       - 멤버변수와 메서드에는 전부 사용가능
	       - 클래스에는 public, default만 사용가능
	       
	     10. 생성자의 접근제어자
	       - 인스턴스의 생성을 제한할 수 있다.
	       - 생성자의 접근제어자를 private으로 변경
	         : 객체생성이 불가하다.
	         : 상속도 불가하다. => 타클래스의 조상이 될 수 없다.
	         : 상속할 수 없는 클래스임으로 final을 추가하여 상속할 수 없는 클래스임을 알리는 것이 좋다.
	       - singleton패턴에 많이 활용된다.
	     
	     11. 캡슐화
	       - 접근제어자를 사용하는 이유
	         : 외부로부터 데이터를 보호하기 위해
	         : 외부에는 불필요하고 내부적으로만 사용되는 부분을 감추기 위해 
	     
	     12. 다형성(polymorphism)
	       - 여러가지 형태를 가질수 있는 능력
	       - 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있다.
	       - 부모타입의 참조변수로 자식타입의 인스턴스를 참조할 수 있다.
	     
	     13. 참조변수의 형변환
	       - 서로 상속관계에 있는 클래스간에는 형변환이 가능하다.
	       - 자식타입 -> 부모타입(up-casting) => 생략 가능
	       - 부모타입 -> 자식타입(down-casting) => 생략 불가
	       
	     14. instanceof
	       - 참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 사용
	       - 연산 결과가 true라면 참조변수가 검사한 타입으로 형변환이 가능하다.
	       - 클래스메서드는 클래스변수처럼 참조변수의 타입에 영향을 받는다.
	       - 참조변수의 타입에 영향을 받지 않는 것은 인스턴스 메서드 뿐이다.
	       
	       FireCar fc = new FireCar();
	       (fc instanceof Car)
	               
		 15. 매개변수의 다형성
		   - 참조변수의 다형적인 특징은 메서드의 매개변수에도 적용이 된다.
		   
		 16. 여러객체 배열 Vector
		   - 배열을 사용할 경우 전체 크기를 한 번 정하면 변경이 불가하다.
		   - 이를 Vector클래스를 이용하여 해결 할 수 있다.
		   - 동적으로 크기가 관리되는 객체배열이라고 생각하면 된다.
		   
		   - Vector클래스의 메서드
		     : Vector() => 10개의 객체를 저장할 수 있는 Vector인스턴스를 생성한다.
		     : add() => 객체를 추가할 때 사용
		     : get(int index) => index번째 방의 객체를 반환한다.
		     : remove() => 객체를 삭제한다.
		     : isEmpty() => Vector에 값이 비어 있는지 확인한다.
		     : size() => 객체의 개수를 반환한다.
		     
		 17. 추상클래스(abstract class)
		   - 추상메서드
		     : 메서드는 선언부와 구현부로 구성되어 있다.
		     : 선언부만 작성이 되고 구현부는 작성하지 않은 메서드를 추상 메서드라고 한다.
		     : 구조
		     	abstract 반환타입 메서드명(매개변수);
		   
		   - 추상 클래스 
		     : 추상메서드를 포함하고 있는 클래스
		     	abstract class 클래스 명{
		     	
		     	}
		     	
		 18. 인터페이스(interface)
		   - 일종의 추상클래스 이지만 추상메서드와 상수만을 멤버로 가질 수 있다.
		   - 인터페이스 작성방법
		     interface 인터페이스명{
		     	public static final 변수타입 변수명 = 값;
		     	public abstract 반환타입 메서드명 (매개변수);
		     } 
		     
		     : 모든 멤버변수는 public static final이어야 한다. => 생략 가능
		     : 모든 메서드는 public abstract이어야 한다. => 생략 가능
		     
		   - 인터페이스 상속
		     : 인터페이스는 클래스를 상속받을 수 없다.
		     : 인터페이스는 인터페이스만 상속받을 수 있다.
		     : 인터페이스는 다중 상속이 가능하다.
		     
		   - 인터페이스의 구현
		     : 자체로는 인스턴스를 생성할 수 없다.
		     : 자신이 정의된 추상메서드의 몸통을 만들어 주는 클래스를 작성해야 한다.
		     : 클래스의 확장(extends), 인터페이스의 구현(implements)을 사용한다.
		     : ~able(~을 할 수 있는) 필요한 메서드를 제공한다는 의미를 강조하기 위해서 쓴다.
		     : IMember -> IMemberImpl
		     
		   - 인터페이스의 장점
		     : 개발시간을 단축시킬 수 있다.
		     : 표준화가 가능하다.
		     : 서로 관계가 없는 클래스들에게 관계를 맺어줄 수 있다.
		     : 독립적인 프로그래밍이 가능하다.
		     
		   - 인터페이스의 이해
		     : 클래스를 사용하는 쪽(user)과 제공하는 쪽(provider)이 있다.
		     : 메서드를 사용하는 쪽에서는 사용하려는 메서드의 선언부만 알면된다.
		       A - I - B
		       
		   - 인터페이스의 다형성
		     : 부모타입의 참조변수로 자식타입의 인스턴스를 참조할 수 있다. (다형성)
		     : 인터페이스 타입의 참조변수로 그를 구현한 구현체의 인스턴스를 참조할 수 있다.
		     
		 19. 내부클래스
		   - 클래스내에 선언된 클래스이다.
		   - 서로 쉽게 접근할 수 있고 외부에는 불필요한 클래스를 감춤으로
		          복잡성을 줄일 수 있다.
		          
		   - 인스턴스클래스
		     : 외부클래스의 인스턴스 멤버와 관련된 작업을 수행
		   - static 클래스
		     : 외부클래스의 클래스멤버와 관련된 작업을 수행
		   - 지역클래스
		     : 선언 영역 내에서만 사용 가능
		   - 익명클래스
		     : 클래스의 선언과 객체의 생성을 동시에 하는 이름없는 클래스
		   
		 */
	}
}
